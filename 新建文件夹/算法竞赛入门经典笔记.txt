把一整行其他字符替换成空格再用istringstream分别>>进变量

DFS和BFS 一个用递归 一个用队列

欧拉道路 1.入度等于出度 或者 只有两个例外且一个入-出=1 一个出-入=1
         2.用dfs不断删除边知道可以删除掉全部则说明图为连通图
(单词顶针可以用欧拉图解决）

先序中序推后序  利用中序第一个为根 在中序中查找 左边为左子树右边右子树 并递归

DFS BFS推树本身： 以BFS为基准在BFS不退后的扫 同时在DFS不退后的找 直到找不到说明已经进入下一层 且每一个的父节点是DFS中往后扫最先看到的在uppercase中的那个 uppercase每次是将上一层的节点存在里面

从效率方面 尽管树遍历不需要判重，图却很有必要判重 不管是DFS还是BFS

从初始状态到目标状态的规划问题 其实每一个状态对应一个节点 而实质就是一个BFS遍历枚举状态问题（记得及时判重） 状态有时候判断需要大量内存可以考虑set或者hash

枚举法优化（如回溯法 迭代加深搜索法 IDA* 等等）的精髓在于及时判断剪枝

感觉BFS比DFS应用更广

回溯法应该是以DFS递归为基础 记得return时恢复设置


分治法与递归法 归并排序与快速排序（看笔记中的选三点的快排实现方法）

洞穴题目 从左到右扫一次 从右到左扫一次 每个点去两次扫描在该位置的较小值

删除一个连续子序列使剩下的有一个长度最大的连续递增子序列：计算每个位置的以他开始和结束的长度最大的连续递增子序列 O（n^2) 然后扫描枚举

有障碍点的图找最大矩形正方形方法：先读入数据之后排序障碍点 之后两个for暴力枚举上下边界 然后在上下边界确定情况下用一个for有顺序地（已经排序了）找最大图形！
最后再找最大！

cease to 停止做sth to do 是已经没有做的那件事情！！！

用dp动态规划最有向无环图的最长路径

目前接触到的dp问题大致是 有多种决策（比如0-1背包的0or1 和最大的树的子树等等） 先想如何定义状态 再找出状态转移方程 再初始化 再填表or刷表 一般是从后到前
如0-1背包问题 d（i，j）表示第i--最后 个物品放进容量j的最优值 则d(i,j)=max( d(i+1,j) , d(i,j-Vi)+Wi ) 实质是0 与 1的决策 答案d[1][c]

感觉动态规划实质就是递推 只不过是将状态储存了下来便于递推！
极其坑的一点是！！！  注意递推填表时的顺序以及必要的初始化！！！！！！！  顺序很重要！！for循环内外层分别是哪个 要递增还是递减等等！！！！