1. 大数取模用竖式 10的幂的话可以每次乘10取模 但是若为10的k次幂可以乘100取模省一半时间！


2.树的孩子兄弟法表示 的前序遍历等价于二叉树的前序遍历
   后序遍历等价于二叉树的中序遍历
   我在找root时用了一个标记和遍历查找的方法 或许可以改进


3.逆转单链表用三个指针 时间复杂度O（n）


4.栈和队列想分别用数组和链表实现 可以用继承+虚函数来实现不同的接口

5.满树是最下面一层叶子结点 其他都有两个孩子
  完全二叉树是满树最后一层可以少掉右边的一些叶子节点


6.树的size和height和delete 均可以用递归来实现！  树非常多功能就是生来递归的！！


7.树的一些性质
    ①n个结点的完全二叉树高度为k=（log2 n）向下取整 +1
    ②完全二叉树按顺序存储编号 设根结点为1则 对于某点k 
       他的两个儿子是2k和2k+1（若超出则为NULL）
       他的父亲是k/2 向下取整
      对于非完全二叉树也可以通过增加虚结点来实现


8.树的孩子兄弟链就是将一棵树表示成二叉树~
  而把二叉树左儿子看成儿子 右儿子看成兄弟 就变成了一棵普通的树！
9.森林变成二叉树：先把每科子树按8的方法变成二叉树 那么没棵子树的根的右儿子都是空的
                  那么把每棵子树作为上一树的右儿子即可
  二叉树变成森林：把最右路径依次断开变成多棵二叉树 之后二叉树变成普通数即可！！


10.如何判断表达树是否合法？
  结点只可能度为0 or 度为2 度为0必为数字 度为2必为运算符

11.树的孩子兄弟表示法其实就是一棵普通树 只不过要到点的其他儿子得需经过左儿子之后向右移动 但是想法之类的都可以把它想成一棵普通树 
    比如找他的高度之类的 同样是递归 
   一个结点的高度等于他所有儿子的最大高度+1 而要去递归所有儿子就是通过左儿子之后向右移

12. 由8 9 11可以看出其实孩子兄弟树可以看成是连接普通树与二叉树的桥梁


13.哈夫曼树的动态or静态实现 其实都是看中了他的合并次数是确定的！！！

14.二叉线索树是把空指针位置利用起来 让他指向下一个中序遍历的位置（当然就需要两个布尔变量来区别左右到底是真的还是指向下一个中序遍历位置） 这样可以不用栈或者递归来实现中序遍历！！！

15.D堆是指有D个儿子而非2个 这个也可以用数组 同样有公式来计算父子的下标关系
   他的高度比较低所以上滤简单 有利于插入
   然而由于儿子多 所以下滤时为了找到最小的儿子比较麻烦

16.上下滤交换时不用真的值交换 把最开始的值保存成tmp之后移一个值就行了 把最后空的那个赋为tmp就行了！！这个东西把3个过程减少成1个  虽然不起眼 但真的是一个很好的思路和想法！！

17.最小背包问题如果采用贪心算法（只能较好解） =====》  优先队列！！！
   本质就是 当操作的东西一直是 一堆东西的最值的那个时
   就可以把这堆东西组织成优先队列（堆）

18.静态表查找：顺序查找 二分查找 插值查找 分块查找

19.归并排序需要一个大小n的临时空间来储存数据再复制进原始数组
   如果使用链表 那么可以链表归并的时候就可以直接来的 但是当然链表的指针也会占空间咯
   而且实现起来也比数组麻烦！

20.其实把递归改成非递归 最好是不要用栈实现的真正的非递归
   借助栈其实就是定义一个任务结点 然后不断的把任务结点进栈和出栈 模仿递归栈而已。。
   有点无赖吧其实！！

21.OJ上二叉树顺序存储的题 其实可以用一个node*数组 然后进行操作模拟~~