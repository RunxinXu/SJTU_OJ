#include <iostream>

using namespace std;
//LCS问题 求最长公共子序列 O(n^2) 动态规划问

//第一个序列{a1,a2,a3,……,an}
//第二个序列{b1,b2,b3,……,bm}
//状态 c(i,j)表示a[0:i]与b[0:j]的最长公共子序列长度
//那么状态转移方程有

//c(i,j)=    0  if(i==0 || j==0 即一个序列为空)    ==========>这个就是初始化状态
//          c(i-1,j-1)  if( a[i]==b[i] )           ==========>两个相同那就是等于之前的状态加上1咯 好理解
//          max( c(i-1,j), c(i,j-1) ) 

//这个什么意思呢？ 假设公共子序列在我们这个子问题上 最后一个元素是 ck
//那么ck 要么等于a[i] 要么等于b[j] 要么都不等于
//那么问题就转化为 我可以单独去掉一个a[i] 我也可以单独去掉一个b[j] 那么这两种情况哪一种好就用哪一种咯！！！



//那么问题继续深入 如何找出它的最长公共子序列？？？
//我们可以用一个规模和c一样大的表格 设做route吧
//在执行LCS时候 如果是第二种情况也就是相等的情况a[i]=b[j] 那么就route[i][j]给一个  向左上角  的符号 
//                                                         因为他之前的序列就是(i-1,j-1)的最长公共子序列
//如果是c(i-1,j)>c(i,j-1) 那么说明之前的序列是(i-1,j) 那么给他一个 向 上  的符号
//同样如果反之  那么说明之前的序列是(i,j-1) 那么给他一个向 左 的符号

//之后从最右下角反向查找 如果遇到向上 or 左的符号 那就往相应方向跳
//如果遇到向左上角的 那么就输出这个字符 并且向左上角跳~
//最后一个reverse就行啦！！

int main()
{
	int n, m;
	cin >> n >> m;
	char *a = new char[n];
	char *b = new char[m];
	for (int i = 0; i < n; ++i)
	{
		cin >> a[i];
	}
	for (int i = 0; i < m; ++i)
	{
		cin >> b[i];
	}

	int **c= new int*[n+1];
	for (int i = 0; i < n+1; ++i)
	{
		c[i] = new int[m+1];
	}

	//c[i][j] 表示a[0:i-1]序列与b[0:j-1]序列的最长公共子序列长度

	for (int i = 0; i < n+1; ++i) c[i][0] = 0;
	for (int i = 0; i < m+1; ++i) c[0][i] = 0;
	//初始化第一步

	for (int i = 1; i <= n; ++i)
	{
		for (int j = 1; j <= m; ++j)
		{
			if (a[i - 1] == b[j - 1])
			{
				c[i][j] = c[i - 1][j - 1] + 1;
				
			}
			else
			{
				if (c[i][j - 1] > c[i - 1][j]) c[i][j] = c[i][j - 1];
				else c[i][j] = c[i - 1][j];
			}
		}
	}

	
	cout << c[n][m];
	return 0;
}